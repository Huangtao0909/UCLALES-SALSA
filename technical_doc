

 UCLALES-SALSA, status 07022019

This document gives a brief description of the central technical aspects of the current development of UCLALES-SALSA.
Major changes are related to model datatypes, output scheme and ice description. This document gives an overview -
for a specific description of procedure interfaces a separate documentation is needed. However, for now this does not
exist, so the reader is referred to the source code files, where the input/output definitions are for the most part
clearly commented.

1. Datatypes

1.1. SALSA
In SALSA, the approach for arranging model variables has been mostly unchanged, but some refactorization has been made.
The mass and number concentrations are stored by class instances from 'src_salsa/classSection.f90'. Each instance describes
one size bin. For example, for aerosol SALSA uses the array 'aero' of length 'nbins', and each cell instantiates the class
'Section'. The type bound variables of 'Section' include the bin limits, particle diameters, and number and volume
concentrations. For details, please review the comments in 'classSection.f90'. The class 'Section' also has two type bound
procedures, 'updateDiameter' and 'updateRhomean', whose basic purpose is self explanatory. The former operates in different
modes, and updates the dry or wet diameter, the diameter of the insoluble part or the "non-spherical" diameter which is
implemented only for ice particles. The dry diameter acts the same way for all particle categories. Wet diameter assumes
spherical particles for both liquid and ice particles (even in the case when ice should be non-spherical!). The non-spherical
diameter uses the ice composition and empirical mass-diameter relations (taken from Morrison and Milbrandt 2015) to derive
the diameter of the maximum dimension of ice crystals. Note that very small or very strongly rimed ice are assumed spherical.
Do not use the non-spherical diameter for anything other than ice particles!! There is no automatic checks for this (maybe
should implement one) and it will fail because ice densities are implicitly assumed.
'updateRhomean' is for calculating the mean bulk density of ice particles, that depends on the ice composition (see the notes
on ice description). 

The instances of SALSA variables are declared in 'src_salsa/mo_salsa_types.f90'. First, the array (of type 'Section')
'allSALSA' acts as the master array for all the bins across all particle categories. Arrays 'aero', 'cloud' etc. correspond
to the similar array originally used in SALSA, but now they are declared as pointers and are associated with their unique
sections of 'allSALSA'. This avoids copying data and it is also possible to simply loop over allSALSA for processes which
are identical for all particle categories (see for example mo_salsa_dynamics.f90/gpparth2o, in the beginning updating diameters ).
'mo_salsa_types.f90' also gives the start and end indexes in allSALSA for each category, so using 'allSALSA' with proper
indices or named category pointer will give identical results. The allocation and association of these arrays is done in
'src_salsa/mo_salsa_init.f90'. 'allSALSA' is also now extensively used in 'src_salsa/mo_salsa_driver.f90'.

1.2. UCLALES

1.2.1. FloatArray derived types
In order to write a clearer and user-friendly interface to model output routines (in Section xx), some new datatypes were
introduced for UCLALES model variables. The master scalar arrays 'a_sclrp' and 'a_sclrt' are declared as REAL in
'src_LES/grid.f90', as usual. Instead, all the prognostic and diagnostic pointer variables, prognostic vector variables,
as well as output diagnostic variables (both analysis and statistics) now have to be of the derived types given in
'src_LES/mo_structured_datatypes.f90', i.e. TYPE(FloatArray0/1/2/3/4d). This is necessary to implement the polymorphic
arrays that make the easy-to-use output scheme possible (explained in Section xx). The model pointer variables and vector
variables are not declared in 'grid.f90', but in separate modules. 'src_LES/mo_progn_state.f90' declares all the prognostic
scalar variables (temperature, water vapour, particle concentrations), 'mo_vector_state.f90' declares all the prognostic
vector variables (i.e. winds), 'mo_diag_state.f90' declares all the diagnostic variables that are needed in calculations
during the model timestep, 'mo_derived_state.f90' all variables that are needed only for the 4d outputs (these are not
stored and are calculated on-demand when writing output, see the output section), and 'mo_ps_state.f90' gives all the
variables needed for profile statistics outputs (also not stored and calculated on-demand). Note that 'mo_ts_state.f90'
for domain mean timeseries is not yet implemented. The modules listed also contain the 'set***' subroutine, where the
variables are initialized according to model configuration. These are called from an initialization routine in
'src_LES/mo_field_state.f90', which in turn is called from 'src_LES/LES.f90'

Each of the FloatArray types contain a pointer 'd', and allocatable array 'alloc' and a procedure pointer 'onDemand'.
The rank of the pointer and allocatable arrays corresponds with that indicated in the name of the derived type. The field
'd' acts as the point of access to data. There are two operating modes:
(1) 'd' can point to an external array, or optionally,
(2)'alloc' can be used to store data in the FieldArray instance, in which case 'd' is associated with 'alloc'.
In both cases, 'd' must be used to access data. The constructor for the FielArray types take two arguments: 'trgt' and 'store'.
In mode 1, 'store=.TRUE.' and the 'trgt' would be an external array. For example the variables in 'mo_progn_state',
where e.g. 'a_tp%d' points to a slice in 'a_sclrp' and so on. In mode 2, 'store=.FALSE.' and 'trgt' is an array of data
that will be stored to 'alloc' (and accessed via 'd'). Examples of this are in 'mo_diag_state.f90'. Note that the initialization
is done using dummy 'zeros3d' and similar arrays. 'alloc' is allocated to have the same shape as the input array and the data
(in this case zeros since it's initialization) is copied.

All the variable names are the same as before, a_tp, a_tt, a_rp, a_rt and so on. In practice, the only difference to before is
that accessing the data goes like 'a_tp%d(iz,ix,iy)'. Note that if these go as input arguments to subroutine, in many case the
actual argument is passed as 'a_tp%d', so the dummy argument is then of type REAL and does not need to be changed.

1.2.2. class FieldArray

In the example modules, the model variables are also passed to FieldArray instances. This derived type is given in
'src_LES/classFieldArray.f90'. There is also another type, the 'ArrayElement', but we'll come back to that later. The FieldArray
instances are essentially lists of the model variables and their attributes (names, dimensions, outputstatus etc) specifically
designed with output in mind: when writing model output, the routines just loop over the variables listed in FieldArray
instances, get all the necessary information automatically and write the output. But they are also usefull elsewhere:
the LES variables are passed to SALSA using the FieldArray instances, which eliminates the large number of arguments in the
subroutine call and makes it unnecessary to pass any unused arrays to SALSA (e.g. ice with level=4), so they also don't need
to be allocated in any form.

The FieldArray type itself is simple with 3 type bound variables: list, count and Initialized. The are many type bound procedures,
which are summarised below. The 'list' is a list of variables and is of type 'ArrayElement' (found in the same file). The
variable 'count' tells the number of variables included in 'list' and 'Initialized' is set to .TRUE. once the first variable is
included in the 'list'.

The type ArrayElement contains the fields for the variable information (documented in the code) as well as the polymorphic pointers
to the actual data, 'p','t', and 'c'. These correspond to the "past" and "tendency" values of prognostic scalars, as well as for the
"current" values in case of prognostic vector variables. Assigning only 'p' is mandatory for all variables, 't', and 'c' optional.
Note that these are pointers to the data defined in 'mo_progn_state.f90' and similar modules, i.e. FieldArray instances do not store
any data nor make copies! They just organize it. New items are added to the FieldArray instances via the 'newField' procedure,
which calls the ArrayElement constructor. Examples of this are in 'mo_progn_state.f90' (where 'Prog' is the relevant FieldArray instance)
and the other similar modules.

1.2.3. The important type bound procedures in FieldArray


1.2.4. Implemented FieldArray instances

The currently implemented FieldArray instances are declared in 'src_LES/mo_field_types.f90', which correspond to the afore mentioned
'state'-modules: Prog for prognostic scalars, Vector for prognostic vectors, Diag for diagnostic variables etc. As mentioned, the FieldArray
type contains procedures to create subsets of the "full" instances according to variable's output status or 'group' (other criteria are
relatively easy to implement later). These are given for the SALSA concentration arrays (makes 'constrain_SALSA.f90' procedures and calculation
of subsidence effects in 'forc.f90' much easier) and then for the subsets of variables marked for output (FieldArray variable
'outputstatus' ==.TRUE.). The outputstatus is defined in 'state'-modules when calling the 'newField' procedure based on model configuration
(level, lbinanl etc.) and the output variable list given in namelist. The FieldArray instances and their subsets are initialized in
'src_LES/mo_field_state.f90'.

1.2.5. Additional notes about using the new classes (******* IMPORTANT ********)

 - If you pass a class instance as a procedure argument, and declare the dummy argument with INTENT(out), you HAVE TO initialize the
   dummy argument instance using the constructor, because otherwise the memory is not allocated e.g. in case of the FloatArray classes.
   Even if/when the actual argument IS initialized, this still has to be done. The same applies with intrinsic datatypes, though. If
   you have a regular FLOAT dummy argument with INTENT(out), it should ALWAYS be initialized with some values in the beginning of the
   procedure. Unfortunately this is not always done even in the original LES code and it is a great way to get memory leak issues, if
   the loops inside the procedure happen to not cover the entire array dimensions...

   A quick way around this is to use INTENT(inout) instead, which allows to pass the allocated memory of the actual argument inside the
   procedure. Just have to be careful, that changing the INTENT status doesn't break anything (most often it doesn't, if the procedure
   is written with any kind of integrity...).


2. Output








